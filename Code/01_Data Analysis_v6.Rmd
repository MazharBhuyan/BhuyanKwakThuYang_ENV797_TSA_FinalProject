---
title: 'Forecasting Unemployment Trends: A Comparative Time Series Analysis of Peru
  and the United States'
author: "Aye Nyein Thu, Mazhar Bhuyan, Yuqi Yang, Jisup Kwak"
date: "2025-03-24"
output:
  html_document: default
  pdf_document: default
editor_options:
  chunk_output_type: console
---

## Setting R code chunk options

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  error = TRUE,   
  results = 'markup',
  tidy.opts = list(width.cutoff = 80),
  tidy = FALSE
)

```

## Loading packages and initializing
```{r packages, warning=FALSE, message=FALSE}
# Load required packages
library(readxl)
library(openxlsx)
library(writexl)
library(dplyr)
library(lubridate)
library(ggplot2)
library(cowplot)
library(forecast)  
library(Kendall)
library(tseries)
library(outliers)
library(tidyverse)
library(smooth)
library(trend)
library(kableExtra)
library(tidyr)
library(gt) #install.packages("gt")
library(gridExtra) #install.packages("gridExtra")
library(zoo)
library(imputeTS)


# Check working directory
getwd()
```

## Importing and Wrangling Data
```{r importing data, results='hide', warning=FALSE, message=FALSE}
## Raw Data Set: Unemployment Rate by Age (Thousands)
# Import data set
UEAge.Thou <- read_excel(
  path="./Data/Raw/UE_Age(Thousands).xlsx", sheet = "Sheet1", col_names = TRUE)

# Format data set
UEAge.Thou_Processed <- UEAge.Thou %>%
  mutate(
    Month = ym(sub("M", "-", Month)), 
    Age15to24.Thou = as.numeric(`15-24`), 
    Age25above.Thou = as.numeric(`25+`),   
    AgeTotal.Thou = as.numeric(`15+`)) %>% 
  rename(Country="Reference area") %>% 
  select(Country,Month,Age15to24.Thou, Age25above.Thou, AgeTotal.Thou) %>% 
  arrange(Country, Month)

## Raw Data Set: Unemployment Rate by Age (%)
# Import data set
UEAge.Per <- read_excel(
  path="./Data/Raw/UE_Age(%).xlsx", sheet = "Sheet1", col_names = TRUE)

# Format data set
UEAge.Per_Processed <- UEAge.Per %>%
  mutate(
    Month = ym(sub("M", "-", Month)), 
    Age15to24.Per = as.numeric(`15-24`), 
    Age25above.Per = as.numeric(`25+`),   
    AgeTotal.Per = as.numeric(`15+`)) %>% 
  rename(Country="Reference area") %>% 
  select(Country,Month,Age15to24.Per, Age25above.Per, AgeTotal.Per) %>% 
  arrange(Country, Month)

## Raw Data Set: Unemployment Rate by Gender (Thousands)
# Import data set
UEGender.Thou <- read_excel(
  path="./Data/Raw/UE_Gender(Thousands).xlsx", sheet = "Sheet1", col_names = TRUE)

# Format data set
UEGender.Thou_Processed <- UEGender.Thou %>%
  mutate(
    Month = ym(sub("M", "-", Month)), 
    Female.Thou = as.numeric(Female), 
    Male.Thou = as.numeric(Male),   
    Total.Thou = as.numeric(Total)) %>% 
  rename(Country="Reference area") %>% 
  select(Country,Month,Female.Thou, Male.Thou, Total.Thou) %>% 
  arrange(Country, Month)

## Raw Data Set: Unemployment Rate by Gender (%)
# Import data set
UEGender.Per <- read_excel(
  path="./Data/Raw/UE_Gender(%).xlsx", sheet = "Sheet1", col_names = TRUE)

# Format data set
UEGender.Per_Processed <- UEGender.Per %>%
  mutate(
    Month = ym(sub("M", "-", Month)), 
    Female.Per = as.numeric(Female), 
    Male.Per = as.numeric(Male),   
    Total.Per = as.numeric(Total)) %>% 
  rename(Country="Reference area") %>% 
  select(Country,Month,Female.Per, Male.Per, Total.Per) %>% 
  arrange(Country, Month)
```

```{r data wrangling Peru, warning=FALSE, message=FALSE}
# Combine all processed data sets 
UE_Countries <- UEAge.Thou_Processed %>% 
  left_join(UEAge.Per_Processed, by=c("Country", "Month")) %>% 
  left_join(UEGender.Thou_Processed, by=c("Country", "Month")) %>% 
  left_join(UEGender.Per_Processed, by=c("Country", "Month")) 

# Extract Peru Data 
Peru <- UE_Countries %>% 
  filter(Country == "Peru") %>% 
  select(-Country, AgeTotal.Per, AgeTotal.Thou) %>% 
  select(Month, Age15to24.Per, Age25above.Per, Female.Per, Male.Per,
         Total.Per, Age15to24.Thou, Age25above.Thou, Female.Thou, Male.Thou,
         Total.Thou) 

# Extract Colombia Data
Peru <- UE_Countries %>% 
  filter(Country == "Colombia") %>% 
  select(-Country, AgeTotal.Per, AgeTotal.Thou) %>% 
  select(Month, Age15to24.Per, Age25above.Per, Female.Per, Male.Per,
         Total.Per, Age15to24.Thou, Age25above.Thou, Female.Thou, Male.Thou,
         Total.Thou) 


# Check Missing Value 
sum(is.na(Peru))

# Extract US Data 
US <- UE_Countries %>% 
  filter(Country == "United States of America",
         Month >= as.Date("2001-01-01") & Month <= as.Date("2024-12-01")) %>% 
  select(-Country, AgeTotal.Per, AgeTotal.Thou) %>% 
  select(Month, Age15to24.Per, Age25above.Per, Female.Per, Male.Per,
         Total.Per, Age15to24.Thou, Age25above.Thou, Female.Thou, Male.Thou,
         Total.Thou) 

# Check Missing Value 
sum(is.na(US))
```

```{r data wrangling global, warning=FALSE, message=FALSE}
# Generate global unemployment data using simple average 
UE_Global <- UE_Countries %>%
  group_by(Month) %>%
  summarise(
    Age15to24.Thou = mean(`Age15to24.Thou`, na.rm = TRUE),
    Age25above.Thou = mean(`Age25above.Thou`, na.rm = TRUE), 
    AgeTotal.Thou = mean(`AgeTotal.Thou`, na.rm = TRUE), 
    Age15to24.Per = mean(`Age15to24.Thou`, na.rm = TRUE),
    Age25above.Per = mean(`Age25above.Per`, na.rm = TRUE), 
    AgeTotal.Per = mean(`AgeTotal.Per`, na.rm = TRUE), 
    Female.Thou = mean(`Female.Thou`, na.rm = TRUE),
    Male.Thou = mean(`Male.Thou`, na.rm = TRUE),
    Total.Thou = mean(`Total.Thou`, na.rm = TRUE),
    Female.Per = mean(`Female.Per`, na.rm = TRUE),
    Male.Per = mean(`Male.Per`, na.rm = TRUE),
    Total.Per = mean(`Total.Per`, na.rm = TRUE))

# Generate global unemployment data using weighted average 
UE_Global_Weighted <- UE_Countries %>%
  filter(apply(UE_Countries[, 3:14], 1, function(x) all(!is.na(x)))) %>%  
  group_by(Month) %>%
  summarise(
    Age15to24.Per = sum(Age15to24.Thou) / sum(Age15to24.Thou / Age15to24.Per), 
    Age25above.Per = sum(Age25above.Thou) / sum(Age25above.Thou / Age25above.Per),
    Female.Per = sum(Female.Thou) / sum(Female.Thou / Female.Per),
    Male.Per = sum(Male.Thou) / sum(Male.Thou / Male.Per),
    Total.Per = sum(Total.Thou) / sum(Total.Thou / Total.Per),
    
    Age15to24.Thou = mean(Age15to24.Thou, na.rm = TRUE),
    Age25above.Thou = mean(Age25above.Thou, na.rm = TRUE),
    Female.Thou = mean(Female.Thou, na.rm = TRUE),
    Male.Thou = mean(Male.Thou, na.rm = TRUE),
    Total.Thou = mean(Total.Thou, na.rm = TRUE)
  )

# Generate weighted global unemployment yearly
UE_Global_Yearly <- UE_Global_Weighted %>% 
  mutate(Year = year(Month)) %>%
  group_by(Year) %>% 
  summarize(across(where(is.numeric), mean)) #%>% 
  #filter(Year >= 2000 & Year <= 2024)
```

## Descriptive Statistics 
### Global Unemployment Status
```{r global, warning=FALSE, message=FALSE}
# Check total no. of countries 
print(length(unique(UE_Countries$Country)))

# Plot global unemployment rate for simple average vs. weighted average 
UE_Global_Combined <- bind_rows(
  UE_Global %>% mutate(Source = "Simple Average"),
  UE_Global_Weighted %>% mutate(Source = "Weighted Average")
)

ggplot(UE_Global_Combined, aes(x = Month, y = Total.Per, color = Source)) +
  geom_line() +               
  labs(title = "Global Unemployment Rate: Simple Vs. Weighted Average",
       x = "Month", y = "Global Unemployment Rate (%)", color = "Source") 

# Plots
# Global Unemployment Rate 
ggplot(UE_Global_Yearly, aes(x = Year, y = Total.Per)) +
  geom_line() +               
  labs(title = "Global Unemployment Rate",
       x = "Year", y = "Global Unemployment Rate (%)")

# Global Unemployment Rate by Age
ggplot(UE_Global_Yearly, aes(x = Year)) +
  geom_line(aes(y = Age15to24.Per, color = "Age 15-24")) +
  geom_line(aes(y = Age25above.Per, color = "Age 25+")) +
  labs(title = "Global Unemployment Rate by Age",
       x = "Year", y = "Global Unemployment Rate (%)", color = "Age Group") +
  scale_color_manual(values = c("Age 15-24" = "blue", "Age 25+" = "red"))

# Global Unemployment Rate by Sex
ggplot(UE_Global_Yearly, aes(x = Year)) +
  geom_line(aes(y = Female.Per, color = "Female")) +
  geom_line(aes(y = Male.Per, color = "Male")) +
  labs(title = "Global Unemployment Rate by Sex",
       x = "Year", y = "Global Unemployment Rate (%)", color = "Sex Group") +
  scale_color_manual(values = c("Female" = "blue", "Male" = "red"))
```

### Unemployment Status in Peru and United States
Starting in January 2022, Peru revised its methodology for compiling labor statistics. As a result, caution is needed when analyzing employment data across this period.

```{r peru, warning=FALSE, message=FALSE}
## Unemployment Status in Peru
p1_PE <- ggplot(Peru, aes(x = Month, y = Total.Thou)) +
  geom_line(color = "blue", alpha = 1) +
  labs(x = "", y = "Unemployment (Thousands)") 

Peru_LF <- Peru %>% 
  mutate(LF.Part = (Total.Thou / Total.Per) * 100) 

p2_PE <- ggplot(Peru_LF, aes(x = Month, y = LF.Part)) +
  geom_line(color = "orange", alpha = 1) +
  labs(x = "", y = "Laborforce Participation (Thousands)")

p3_PE <- ggplot(Peru, aes(x = Month, y = Total.Per)) +
  geom_line(color = "red", alpha = 1) +
  labs(x = "Year", y = "Unemployment Rate (%)") 

grid.arrange(p1_PE, p2_PE, p3_PE, ncol = 3,
             top = "Unemployment Status in Colombia")


## US Unemployment Status in US 
p1_US <- ggplot(US, aes(x = Month, y = Total.Thou)) +
  geom_line(color = "blue", alpha = 1) +
  labs(x = "", y = "Unemployment (Thousands)") 

p2_US <- ggplot(US, aes(x = Month, y = Total.Per)) +
  geom_line(color = "red", alpha = 1) +
  labs(x = "Year", y = "Unemployment Rate (%)") 

US_LF <- US %>% 
  mutate(LF.Part = (Total.Thou / Total.Per) * 100) 

p3_US <- ggplot(US_LF, aes(x = Month, y = LF.Part)) +
  geom_line(color = "orange", alpha = 1) +
  labs(x = "", y = "Laborforce Participation (Thousands)")

# Arrange plots side by side
grid.arrange(p1_PE, p2_PE, p3_PE, ncol = 3,
             top = "Unemployment Status in the US")

# Comparison of Unemployment Rate between Peru and US
UE_Comparison <- UE_Countries %>% 
  filter(Country %in% c("Peru", "United States of America")) %>% 
  mutate(Month = as.Date(Month)) %>% 
  filter(Month >= as.Date("2001-01-01") & Month <= as.Date("2024-12-01"))

ggplot(UE_Comparison, aes(x = Month, y = Total.Per, color = Country)) +
  geom_line(size = 0.8) +  
  geom_point(size = 0.8, alpha = 0.7) + 
  theme_gray(base_size = 14) +  
  labs(title = "Unemployment Rate by Countries (2001-2024)",
    x = "Year", y = "Unemployment Rate (%)", color = "Country") +
  theme(plot.title = element_text(face = "bold", size = 16),
    axis.title.y = element_text(size = 14), axis.text = element_text(size = 12),
    legend.position = "right")

# Comparison of Unemployment Rate by Age Group 
PE1 <- ggplot(Peru, aes(x = Month)) +
  geom_line(aes(y = Age15to24.Per, color = "Age 15-24"), size = 0.8) +
  geom_line(aes(y = Age25above.Per, color = "Age 25+"), size = 0.8) +
  geom_point(aes(y = Age15to24.Per, color = "Age 15-24"), size = 0.8, alpha = 0.5) +
  geom_point(aes(y = Age25above.Per, color = "Age 25+"), size = 0.8, alpha = 0.5) +
  labs(title = "Unemployment Rate by Age Group",
    x = "Year", y = "Peru Unemployment Rate (%)", color = "Age Group") +
  scale_color_manual(values = c("Age 15-24" = "blue", "Age 25+" = "red")) +
  theme_gray(base_size = 12) +  
  theme(plot.title = element_text(size = 14),
    axis.title.x = element_text(size = 12), axis.title.y = element_text(size = 12),
    axis.text = element_text(size = 12), legend.position = "bottom") 

US1 <- ggplot(US, aes(x = Month)) +
  geom_line(aes(y = Age15to24.Per, color = "Age 15-24"), size = 0.8) +
  geom_line(aes(y = Age25above.Per, color = "Age 25+"), size = 0.8) +
  geom_point(aes(y = Age15to24.Per, color = "Age 15-24"), size = 0.8, alpha = 0.5) +
  geom_point(aes(y = Age25above.Per, color = "Age 25+"), size = 0.8, alpha = 0.5) +
  labs(title = "",
    x = "Year", y = "US Unemployment Rate (%)", color = "Age Group") +
  scale_color_manual(values = c("Age 15-24" = "blue", "Age 25+" = "red")) +
  theme_gray(base_size = 12) +  
  theme(plot.title = element_text(size = 14),
    axis.title.x = element_text(size = 12), axis.title.y = element_text(size = 12),
    axis.text = element_text(size = 12), legend.position = "bottom")

grid.arrange(PE1, US1, ncol = 2)

# Comparison of Unemployment Rate by Sex Group 
sPE1 <- ggplot(Peru, aes(x = Month)) +
  geom_line(aes(y = Female.Per, color = "Female"), size = 0.8) +
  geom_line(aes(y = Male.Per, color = "Male"), size = 0.8) +
  geom_point(aes(y = Female.Per, color = "Female"), size = 0.8, alpha = 0.5) +
  geom_point(aes(y = Male.Per, color = "Male"), size = 0.8, alpha = 0.5) +
  labs(title = "Unemployment Rate by Sex Group",
    x = "Year", y = "Peru Unemployment Rate (%)", color = "Sex Group") +
  scale_color_manual(values = c("Female" = "blue", "Male" = "red")) +
  theme_gray(base_size = 12) +  
  theme(plot.title = element_text(size = 14),
    axis.title.x = element_text(size = 12), axis.title.y = element_text(size = 12),
    axis.text = element_text(size = 12), legend.position = "bottom") 

sUS1 <- ggplot(US, aes(x = Month)) +
  geom_line(aes(y = Female.Per, color = "Female"), size = 0.8) +
  geom_line(aes(y = Male.Per, color = "Male"), size = 0.8) +
  geom_point(aes(y = Female.Per, color = "Female"), size = 0.8, alpha = 0.5) +
  geom_point(aes(y = Male.Per, color = "Male"), size = 0.8, alpha = 0.5) +
  labs(title = "",
    x = "Year", y = "US Unemployment Rate (%)", color = "Sex Group") +
  scale_color_manual(values = c("Female" = "blue", "Male" = "red")) +
  theme_gray(base_size = 12) +  
  theme(plot.title = element_text(size = 14),
    axis.title.x = element_text(size = 12), axis.title.y = element_text(size = 12),
    axis.text = element_text(size = 12), legend.position = "bottom") 

grid.arrange(sPE1, sUS1, ncol = 2)
```

# Additional graphs(Jisup)
# Innitial plot of Peru as the perspective of the level of unemployment

```{r}
peru_unemployment <- Peru

# Check for missing values
summary(peru_unemployment)
sum(is.na(peru_unemployment))


# Check regularity of time index
diff_date <- diff(peru_unemployment$Month)
table(diff_date)  # There's one missing month.
peru_unemployment$Month <- as.Date(peru_unemployment$Month)


# Create full monthly sequence
full_month_seq <- data.frame(Month = seq.Date(from = min(peru_unemployment$Month),to = max(peru_unemployment$Month),
                                              by = "month"))

# Join with original to find missing months
missing_months <- full_month_seq %>%
  anti_join(peru_unemployment, by = "Month")

print(missing_months)  # Missing month is 2012-09-01

# Fill in missing months with NA
#peru_unemployment <- full_month_seq %>%
#  left_join(peru_unemployment, by = "Month")


# Check for outliers visually
boxplot(peru_unemployment$Total.Thou,
        main = "Boxplot: Peru AgeTotal.Thou",
        horizontal = TRUE,
        col = "lightblue")

boxplot(peru_unemployment$Total.Per,
        main = "Boxplot: Peru Total Unemplyment Rate",
        horizontal = TRUE,
        col = "lightblue")

boxplot(Peru_LF$Total.Thou,
        main = "Boxplot: Peru AgeTotal.employment_Thou",
        horizontal = TRUE,
        col = "lightblue")



# Convert to time series
ts_peru_total_thou <- ts(peru_unemployment$Total.Thou,
               start = c(2001, 4), 
               frequency = 12)
ts_peru_total_per <- ts(peru_unemployment$Total.Per,
               start = c(2001, 4), 
               frequency = 12)
ts_peru_employment_thou <- ts(Peru_LF$LF.Part,
               start = c(2001, 4), 
               frequency = 12)


# interpolation of NA
ts_peru_total_thou <- na_interpolation(ts_peru_total_thou, option = "linear")
ts_peru_total_per <- na_interpolation(ts_peru_total_per, option = "linear")
ts_peru_employment_thou <- na_interpolation(ts_peru_employment_thou, option = "linear")

sum(is.na(ts_peru_total_thou))
sum(is.na(ts_peru_total_per))
sum(is.na(ts_peru_employment_thou))

length(peru_unemployment$Month)           
length(ts_peru_total_thou)                
length(ts_peru_employment_thou)           
length(ts_peru_total_per)                 



# plotting the graph
peru_plot_data <- data.frame(
  Month = peru_unemployment$Month,
  Unemployment_Level = as.numeric(ts_peru_total_thou),
  Employment_Level = as.numeric(ts_peru_employment_thou),
  Unemployment_Rate_Percent = as.numeric(ts_peru_total_per)
)


p <- ggplot(peru_plot_data, aes(x = Month)) +
  geom_line(aes(y = Unemployment_Level*1.1, color = "Unemployment Level"), size = 1) +
  geom_line(aes(y = Employment_Level, color = "Employment Level"), size = 1) +
  geom_line(aes(y = Unemployment_Rate_Percent * 1000, color = "Unemployment Rate [%]"), size = 1) +
  scale_y_continuous(
    name = "Unemployment [Thousands]",
    limits = c(0, 30000),
    sec.axis = sec_axis(~./1000, name = "Unemployment Rate [%]", breaks = seq(0, 20, 5))
  ) +
  scale_color_manual(
    name = "Legend",
    values = c(
      "Unemployment Level" = "darkblue",
      "Employment Level" = "darkorange",
      "Unemployment Rate [%]" = "gray"
    )
  ) +
  labs(
    title = "Colombia: Employment, Unemployment Count and Rate Over Time",
    x = "Month"
  ) +
  theme_minimal()

print(p)

# Decompose the time series
decomp_ts_peru_total_thou <- decompose(ts_peru_total_thou)
plot(decomp_ts_peru_total_thou)
decomp_ts_peru_total_per <- decompose(ts_peru_total_per)
plot(decomp_ts_peru_total_per)
decomp_ts_peru_employment_thou <- decompose(ts_peru_employment_thou)
plot(decomp_ts_peru_employment_thou)

# ACF and PACF plots
par(mfrow = c(1, 2))
Acf(ts_peru_total_thou, lag.max = 40, main = "ACF: Peru AgeTotal.Thou")
Pacf(ts_peru_total_thou, lag.max = 40, main = "PACF: Peru AgeTotal.Thou")

par(mfrow = c(1, 2))
Acf(ts_peru_total_per, lag.max = 40, main = "ACF: Peru AgeTotal.Thou")
Pacf(ts_peru_total_per, lag.max = 40, main = "PACF: Peru AgeTotal.Thou")

par(mfrow = c(1, 2))
Acf(ts_peru_employment_thou, lag.max = 40, main = "ACF: Peru AgeTotal.Thou")
Pacf(ts_peru_employment_thou, lag.max = 40, main = "PACF: Peru AgeTotal.Thou")

# Grubbs test for outliers
grubbs.test(ts_peru_total_thou)
grubbs.test(ts_peru_total_per)
grubbs.test(ts_peru_employment_thou)
```

# Additional graphs(Jisup)
# Innitial plot of US as the perspective of the level of unemployment

```{r}
us_unemployment <- read_excel(
  path="./Data/Raw/Final Project_data_20250403_R.xlsx", sheet = "US_unemployment", col_names = TRUE)

# Check for missing values
summary(us_unemployment)
sum(is.na(us_unemployment))



# 1. Filtering after 2001
us_unemployment_filtered <- us_unemployment %>%
  filter(Month >= as.Date("2001-01-01"))

# 2. Plot
ggplot(us_unemployment_filtered, aes(x = Month)) +
  geom_line(aes(y = AgeTotal.Thou, color = "Unemployment Level"), size = 1) +
  geom_line(aes(y = Employment_level, color = "Employment Level"), size = 1) +
  geom_line(aes(y = AgeTotal.Per * 7500, color = "Unemployment Rate [%]"), size = 1) +
  scale_y_continuous(
    name = "Employment / Unemployment [Thousands]",
    limits = c(0, 150000), 
    sec.axis = sec_axis(~./7500, name = "Unemployment Rate [%]", breaks = seq(0, 20, 5))
  ) +
  scale_color_manual(
    name = "Legend",
    values = c(
      "Unemployment Level" = "darkblue",
      "Employment Level" = "darkorange",
      "Unemployment Rate [%]" = "gray"
    )
  ) +
  labs(
    title = "US: Employment, Unemployment Count and Rate Since 2001",
    x = "Month"
  ) +
  theme_minimal()



# Check regularity of time index
diff_date <- diff(us_unemployment$Month)
table(diff_date)  # There's one missing month.
us_unemployment$Month <- as.Date(us_unemployment$Month)


# Create full monthly sequence
full_month_seq <- data.frame(Month = seq.Date(from = min(us_unemployment$Month),to = max(us_unemployment$Month),
                                              by = "month"))

# Join with original to find missing months
missing_months <- full_month_seq %>%
  anti_join(us_unemployment, by = "Month")

print(missing_months) # no NAs

# Check for outliers visually
boxplot(us_unemployment$AgeTotal.Thou,
        main = "Boxplot: US AgeTotal.Thou",
        horizontal = TRUE,
        col = "lightblue")

boxplot(us_unemployment$AgeTotal.Per,
        main = "Boxplot: US AgeTotal.Thou",
        horizontal = TRUE,
        col = "lightblue")

boxplot(us_unemployment$Employment_level,
        main = "Boxplot: US AgeTotal.Thou",
        horizontal = TRUE,
        col = "lightblue")



# Convert to time series
ts_us_total_thou <- ts(us_unemployment$AgeTotal.Thou,
               start = c(2001, 4), 
               frequency = 12)
ts_us_total_per <- ts(us_unemployment$AgeTotal.Per,
               start = c(2001, 4), 
               frequency = 12)
ts_us_employment_thou <- ts(us_unemployment$Employment_level,
               start = c(2001, 4), 
               frequency = 12)

# Decompose the time series
decomp_ts_us_total_thou <- decompose(ts_us_total_thou)
plot(decomp_ts_us_total_thou)
decomp_ts_us_total_per <- decompose(ts_us_total_per)
plot(decomp_ts_us_total_per)
decomp_ts_us_employment_thou <- decompose(ts_us_employment_thou)
plot(decomp_ts_us_employment_thou)

# ACF and PACF plots
par(mfrow = c(1, 2))
Acf(ts_us_total_thou, lag.max = 40, main = "ACF: us AgeTotal.Thou")
Pacf(ts_us_total_thou, lag.max = 40, main = "PACF: us AgeTotal.Thou")

par(mfrow = c(1, 2))
Acf(ts_us_total_per, lag.max = 40, main = "ACF: us AgeTotal.Thou")
Pacf(ts_us_total_per, lag.max = 40, main = "PACF: us AgeTotal.Thou")

par(mfrow = c(1, 2))
Acf(ts_us_employment_thou, lag.max = 40, main = "ACF: us AgeTotal.Thou")
Pacf(ts_us_employment_thou, lag.max = 40, main = "PACF: us AgeTotal.Thou")

# Grubbs test for outliers
grubbs.test(ts_us_total_thou)
grubbs.test(ts_us_total_per)
grubbs.test(ts_us_employment_thou)
```

# Additional graphs(Jisup)
# Comparing Peru and US(Population and GDP growth)
```{r}
gdp_growth <- read_excel(
  path="./Data/Raw/Final Project_data_20250403_R.xlsx", sheet = "US_GDP", col_names = TRUE)
gdp_growth <- gdp_growth[244:nrow(gdp_growth), ]


pop_growth <- read_excel(
  path="./Data/Raw/Final Project_data_20250403_R.xlsx", sheet = "US_Population", col_names = TRUE)
pop_growth <- pop_growth[80:nrow(pop_growth), ]


# Check for missing values
summary(gdp_growth)
sum(is.na(gdp_growth))

summary(pop_growth)
sum(is.na(pop_growth))


# 2. Plot
ggplot(gdp_growth, aes(x = observation_date)) +
  geom_line(aes(y = `Peru GDP growth`, color = "Peru GDP Growth"), size = 1) +
  geom_line(aes(y = `US GDP growth`, color = "US GDP Growth"), size = 1) +
  scale_color_manual(
    name = "Legend",
    values = c(
      "Peru GDP Growth" = "darkblue",
      "US GDP Growth" = "darkorange"
    )
  ) +
  labs(
    title = "US & Peru: Quarterly GDP Growth Since 2008",
    x = "Date",
    y = "GDP Growth (%)"
  ) +
  theme_minimal()

ggplot(pop_growth, aes(x = observation_date)) +
  geom_line(aes(y = peru_pop_growth, color = "Peru Population Growth"), size = 1) +
  geom_line(aes(y = US_pop_growth, color = "US Population Growth"), size = 1) +
  scale_color_manual(
    name = "Legend",
    values = c(
      "Peru Population Growth" = "darkblue",
      "US Population Growth" = "darkorange"
    )
  ) +
  labs(
    title = "US & Peru: Quarterly Population Growth Since 2008",
    x = "Date",
    y = "Population Growth (%)"
  ) +
  theme_minimal()

```



### Missing month handling
```{r missing month handling}
## PERU
# Check regularity of time index
diff_date <- diff(Peru$Month)
table(diff_date)  # There's one missing month.

# Create full monthly sequence
full_month_seq <- data.frame(Month = seq.Date(from = min(Peru$Month),
                                              to = max(Peru$Month),
                                              by = "month"))

# Join with original to find missing months
missing_months <- full_month_seq %>%
  anti_join(Peru, by = "Month")

print(missing_months)  # Missing month is 2012-09-01

# Fill in missing months with NA and interpolate linearly
Peru <- full_month_seq %>%
  left_join(Peru, by = "Month") %>% 
  mutate(across(where(is.numeric), ~na.approx(.x, na.rm = FALSE)))

## US 
diff_date <- diff(US$Month)
table(diff_date)  # There's no missing month.
```

### Summary Statistics 
```{r Peru summary stats table}
## PERU
# Generate Summary Statistics
summary_table <- Peru %>%
  select(-Month) %>%  # Exclude Month column
  summarise(across(where(is.numeric), 
                   list(Mean = ~ mean(.x),
                        SD = ~ sd(.x),
                        Min = ~ min(.x),
                        Max = ~ max(.x),
                        N = ~ sum(!is.na(.x))))) %>%
  pivot_longer(everything(), names_to = c("Variable", ".value"), names_sep = "_") %>% 
  gt() %>%
  tab_header(title = "Summary Statistics of Unemployment Data in Colombia",
    subtitle = "Monthly Data (2001-2024)") %>%
  fmt_number(columns = 2:6, decimals = 2) %>%
  cols_label(Variable = "Indicator", Mean = "Mean", SD = "Standard Deviation",
    Min = "Min", Max = "Max", N = "Observations") %>%
  tab_options(table.font.size = px(14),
    heading.title.font.size = px(18), heading.subtitle.font.size = px(14))

print(summary_table)   # During knitting, this should not be excuted.

summary_table <- Peru %>%
  select(-Month) %>%
  summarise(across(where(is.numeric), 
                   list(Mean = ~ mean(.x),
                        SD = ~ sd(.x),
                        Min = ~ min(.x),
                        Max = ~ max(.x),
                        N = ~ sum(!is.na(.x))))) %>%
  pivot_longer(everything(), names_to = c("Variable", ".value"), names_sep = "_")

knitr::kable(summary_table, digits = 2, caption = "Summary Statistics of Unemployment Data in Peru")


# Check outliers 
outlier(Peru) 
grubbs.test(Peru$Age15to24.Thou) # This is an outlier. 
grubbs.test(Peru$Age25above.Thou) # This is an outlier. 
grubbs.test(Peru$Age15to24.Per) 
grubbs.test(Peru$Age25above.Per)
grubbs.test(Peru$Female.Thou) # This is an outlier. 
grubbs.test(Peru$Male.Thou) # This is an outlier. 
grubbs.test(Peru$Female.Per)
grubbs.test(Peru$Male.Per)
grubbs.test(Peru$Total.Thou) # This is an outlier. 
grubbs.test(Peru$Total.Per)

# Check the box plot for total unemployment (for PPT)
boxplot(Peru$Total.Per,
        main = "Boxplot: Colombia Unemployment Rate (%)",
        horizontal = TRUE, 
        col = "lightblue")

# Plotting for total unemployment, ACF, PACF (for PPT)
ts_peru_ppt <- ts(Peru$Total.Per, start = c(2001, 1), frequency = 12)
p1 <- autoplot(ts_peru_ppt) +
  ggtitle("Colombia") +
  ylab("Unemployment Rate (%)") +
  xlab("Time")

p2 <- ggAcf(ts_peru_ppt, lag.max = 40) +
  ggtitle("ACF")

p3 <- ggPacf(ts_peru_ppt, lag.max = 40) +
  ggtitle("PACF")

grid.arrange(p1, p2, p3, ncol = 3)


# Find the row where Total.Per is the outlier (10.8%)
outlier_row <- Peru %>%
  filter(Total.Per == max(Total.Per, na.rm = TRUE))

print(outlier_row) # Highest Value is 2005-02-01. 
```

```{r US summary stats table}
## PERU
# Generate Summary Statistics
summary_tableUS <- US %>%
  select(-Month) %>%  # Exclude Month column
  summarise(across(where(is.numeric), 
                   list(Mean = ~ mean(.x),
                        SD = ~ sd(.x),
                        Min = ~ min(.x),
                        Max = ~ max(.x),
                        N = ~ sum(!is.na(.x))))) %>%
  pivot_longer(everything(), names_to = c("Variable", ".value"), names_sep = "_") %>% 
  gt() %>%
  tab_header(title = "Summary Statistics of Unemployment Data in US",
    subtitle = "Monthly Data (2001-2024)") %>%
  fmt_number(columns = 2:6, decimals = 2) %>%
  cols_label(Variable = "Indicator", Mean = "Mean", SD = "Standard Deviation",
    Min = "Min", Max = "Max", N = "Observations") %>%
  tab_options(table.font.size = px(14),
    heading.title.font.size = px(18), heading.subtitle.font.size = px(14))

print(summary_tableUS) # During knitting, this should not be excuted.

summary_tableUS_simple <- US %>%
  select(-Month) %>%  
  summarise(across(where(is.numeric), 
                   list(Mean = ~ mean(.x),
                        SD = ~ sd(.x),
                        Min = ~ min(.x),
                        Max = ~ max(.x),
                        N = ~ sum(!is.na(.x))))) %>%
  pivot_longer(everything(), names_to = c("Variable", ".value"), names_sep = "_")

knitr::kable(summary_tableUS_simple, digits = 2, caption = "Summary Statistics of Unemployment Data in US")


# Check outliers 
outlier(US) 
grubbs.test(US$Age15to24.Thou) 
grubbs.test(US$Age25above.Thou) # This is an outlier. 
grubbs.test(US$Age15to24.Per) # This is an outlier. 
grubbs.test(US$Age25above.Per) # This is an outlier. 
grubbs.test(US$Female.Thou) # This is an outlier. 
grubbs.test(US$Male.Thou) 
grubbs.test(US$Female.Per) # This is an outlier. 
grubbs.test(US$Male.Per)
grubbs.test(US$Total.Thou) # This is an outlier. 
grubbs.test(US$Total.Per) # This is an outlier. 

# Check the box plot for total unemployment 
boxplot(US$Total.Per,
        main = "Boxplot: US Unemployment Rate (%)",
        horizontal = TRUE, 
        col = "lightblue")

# Find the row where Total.Per is the outlier (14.4%)
outlier_rowUS <- US %>%
  filter(Total.Per == max(Total.Per, na.rm = TRUE))

print(outlier_rowUS) # Outlier is 2020-04-01. 
```

## Time Series Analysis for Peru 
### Step 1: Transform into time series and set training and testing windows for Peru

```{r}
# Transform into time series
# 201001~202412
# Transform into time series
ts_Peru <- ts(Peru[,2:11],
              start=c(year(Peru$Month[1]), month(Peru$Month[1])),
              frequency = 12)

# Set the period
nobs = nrow(Peru)
n_for = 12

# Create a subset for training purpose 
ts_Peru_train <- ts(Peru[97:(nobs-n_for),2:11],
                    start=c(2010, 1),
                    frequency = 12)
head(ts_Peru_train)
tail(ts_Peru_train)

# Create a subset for testing purpose
start_row = nobs - n_for + 1
ts_Peru_test <- ts(Peru[(nobs-n_for+1):nobs,2:11],
                   start=c(year(Peru$Month[start_row]),
                           month(Peru$Month[start_row])), frequency = 12)
head(ts_Peru_test)
tail(ts_Peru_test)

# Plots 
train <- autoplot(ts_Peru_train[,"Total.Per"]) + ylab("Unemployment Rate (%)") +
  ggtitle("Training Window")
test <- autoplot(ts_Peru_test[,"Total.Per"]) + ylab("Unemployment Rate (%)") +
  ggtitle("Testing Window")
grid.arrange(train, test, ncol = 2)

par(mfrow=c(1,2))
  Acf(ts_Peru_train[,"Total.Per"], lag=40, plot = TRUE, main = "")
  Pacf(ts_Peru_train[,"Total.Per"], lag=40, plot = TRUE, main = "")

```

### Step 2: Decompose the time series for Peru
```{r total.per decompose of Peru, warning=FALSE, message=FALSE}
# Decompose 
decom_totalper_train <- decompose(ts_Peru_train[,"Total.Per"])
plot(decom_totalper_train)

# Deseason 
deseas_totalper_train <- seasadj(decom_totalper_train)  
plot(deseas_totalper_train)

# Run the tests on deseasoned series
print(adf.test(deseas_totalper_train, alternative = "stationary")) # It is unit root. 
summary(MannKendall(deseas_totalper_train)) # It has a decreasing trend.

# Run the tests on original series 
print(adf.test(ts_Peru_train[,"Total.Per"], alternative = "stationary")) # It is stationary. 
summary(SeasonalMannKendall(ts_Peru_train[,"Total.Per"])) 
summary(smk.test(ts_Peru_train[,"Total.Per"])) # It has seasonality. 

# Check for any differencing needed 
print(ndiffs(ts_Peru_train[,"Total.Per"]))
print(ndiffs(deseas_totalper_train))
```

### Step 3: Test Time Series Models for Peru
```{r time series models Peru, warning=FALSE, message=FALSE}
# Seasonal Naive Model 
SNAIVE_deseas_totalper <- snaive(ts_Peru_train[,"Total.Per"], h=n_for)
autoplot(SNAIVE_deseas_totalper)
checkresiduals(SNAIVE_deseas_totalper)

# Simple Moving Average Model
SMA_deseas_totalper <- smooth::sma(y = deseas_totalper_train, h=n_for, 
                                   holdout = FALSE, silent = FALSE) 
summary(SMA_deseas_totalper)
autoplot(SMA_deseas_totalper$fitted)
checkresiduals(SMA_deseas_totalper) # Residuals are not iid.

# Simple Exponential Smoothing Model
SES_deseas_totalper = ses(y = deseas_totalper_train, h=n_for, 
                          holdout = FALSE, silent = FALSE)  
summary(SES_deseas_totalper)
autoplot(SES_deseas_totalper)
checkresiduals(SES_deseas_totalper) # Residuals are not iid. 

# SARIMA Model
SARIMA_totalper <- auto.arima(ts_Peru_train[,"Total.Per"])
print(SARIMA_totalper)

SARIMA_forecast_totalper <- forecast(object = SARIMA_totalper, h=n_for)
autoplot(SARIMA_forecast_totalper)
checkresiduals(SARIMA_forecast_totalper) # Residuals are iid.

# Deaseasoned ARIMA Model
ARIMA_totalper <- auto.arima(deseas_totalper_train, max.D = 0, 
                             max.P = 0, max.Q = 0)
print(ARIMA_totalper)

ARIMA_forecast_totalper <- forecast(object = ARIMA_totalper, h=n_for)
autoplot(ARIMA_forecast_totalper)
checkresiduals(ARIMA_forecast_totalper) # Residuals are iid.
 
# STL + ETS Model
ETS_totalper <-  stlf(ts_Peru_train[,"Total.Per"],h=n_for)
autoplot(ETS_totalper) 
checkresiduals(ETS_totalper) # Residuals are not iid. 

# ARIMA + FOURIER Model
ARIMA_Four_fit_totalper <- auto.arima(ts_Peru_train[,"Total.Per"], 
                             seasonal=FALSE, lambda=0,
                             xreg=fourier(ts_Peru_train[,"Total.Per"], 
                                          K=3))

ARIMA_Four_for_totalper <- forecast(ARIMA_Four_fit_totalper,
                           xreg=fourier(ts_Peru_train[,"Total.Per"],
                                        K=3, h=n_for),
                           h=n_for) 

autoplot(ARIMA_Four_for_totalper)
checkresiduals(ARIMA_Four_for_totalper) # Better fit

# TBATS Model 
TBATS_fit_totalper <- tbats(ts_Peru_train[,"Total.Per"])
TBATS_for_totalper <- forecast(TBATS_fit_totalper, h = n_for)
autoplot(TBATS_for_totalper) 
checkresiduals(TBATS_fit_totalper) # Better fit

# Neural Network Model 
NN_fit_totalper <- nnetar(ts_Peru_train[,"Total.Per"],
                          p=3, P=0,
                          xreg=fourier(ts_Peru_train[,"Total.Per"], K=3))

NN_for_totalper <- forecast(NN_fit_totalper, 
                   h=n_for,
                   xreg=fourier(ts_Peru_train[,"Total.Per"], 
                                          K=3,h=n_for))

autoplot(NN_for_totalper)
checkresiduals(NN_fit_totalper) # Residuals are not iid.

## State Space Exponential Smoothing Model
SSES_seas_totalper <- es(ts_Peru_train[,"Total.Per"],
                         model="ZZZ", h=n_for, holdout=FALSE)

plot(SSES_seas_totalper$fitted, type = "l", col = "blue", main = "Fitted Values from SSES Model")
lines(SSES_seas_totalper$forecast, col = "red")
checkresiduals(SSES_seas_totalper) # Residuals are not iid.

## State Space with BSM Model
SS_seas_totalper <- StructTS(ts_Peru_train[,"Total.Per"],
                    type="BSM",fixed=c(0.01,0.001,0.1,NA)) 

SS_for_totalper <- forecast(SS_seas_totalper,h=n_for)

plot(SS_for_totalper)
checkresiduals(SS_seas_totalper) # Residuals are not iid. 
```

### Step 4: Performance check for Peru
```{r accuracy Peru, warning=FALSE, message=FALSE}
# Check accuracy of the models
SANIVE_tpscores <- accuracy(SNAIVE_deseas_totalper$mean,ts_Peru_test[,"Total.Per"])  
SMA_tpscores <- accuracy(SMA_deseas_totalper$forecast,ts_Peru_test[,"Total.Per"])  
SES_tpscores <- accuracy(SES_deseas_totalper$mean,ts_Peru_test[,"Total.Per"])
SARIMA_tpscores <- accuracy(SARIMA_forecast_totalper$mean,ts_Peru_test[,"Total.Per"])
ARIMA_tpscores <- accuracy(ARIMA_forecast_totalper$mean,ts_Peru_test[,"Total.Per"])
ETS_tpscores <- accuracy(ETS_totalper$mean,ts_Peru_test[,"Total.Per"])
ARIMA_Four_tpscores <- accuracy(ARIMA_Four_for_totalper$mean,ts_Peru_test[,"Total.Per"])
TBATS_tpscores <- accuracy(TBATS_for_totalper$mean,ts_Peru_test[,"Total.Per"])
NN_tpscores <- accuracy(NN_for_totalper$mean,ts_Peru_test[,"Total.Per"])
SSES_tpscores <- accuracy(SSES_seas_totalper$forecast,ts_Peru_test[,"Total.Per"])
SS_tpscores <- accuracy(SS_for_totalper$mean,ts_Peru_test[,"Total.Per"])

# Compare the matrix 
tpscores <- as.data.frame(rbind(SANIVE_tpscores, SMA_tpscores, 
                                SES_tpscores, SARIMA_tpscores, ARIMA_tpscores, 
                                ETS_tpscores, ARIMA_Four_tpscores, TBATS_tpscores, 
                                NN_tpscores, SSES_tpscores, SS_tpscores)) %>%
  mutate(Average = rowMeans(., na.rm = TRUE))

row.names(tpscores) <- c("SNAIVE", "SMA", "SES", "SARIMA", "ARIMA",
                       "ETS", "ARIMA_FOURIER", "TBATS", "NNETAR",
                       "SSES", "BSM")

# Choose model with lowest error
best_model_index_tp <- which.min(tpscores[,"Average"])
cat("The best model by Average is:", row.names(tpscores[best_model_index_tp,]))  

# Create Tables 
kbl(tpscores, 
      caption = "Forecast Accuracy for Unemployment Rate (%) Data",
      digits = array(5,ncol(tpscores))) %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  #highlight model with lowest RMSE
  kable_styling(latex_options="striped", stripe_index = which.min(tpscores[,"Average"]))

# Plot everything together
autoplot(ts_Peru_test[,"Total.Per"]) +
  ylab("Unemployment Rate [%]") +
  autolayer(SNAIVE_deseas_totalper, PI=FALSE, series="SNAIVE") + 
  autolayer(SES_deseas_totalper, PI=FALSE, series="SES") +
  autolayer(SARIMA_forecast_totalper, PI=FALSE, series="SARIMA") +
  autolayer(ARIMA_forecast_totalper, PI=FALSE, series="ARIMA") +
  autolayer(ETS_totalper, PI=FALSE, series="ETS") +
  autolayer(ARIMA_Four_for_totalper, PI=FALSE, series="ARIMA_FOURIER") +
  autolayer(TBATS_for_totalper, PI=FALSE, series="TBATS") +
  autolayer(NN_for_totalper, PI=FALSE, series="NNETAR") +
  autolayer(SS_for_totalper, PI=FALSE, series="BSM") +
  guides(colour=guide_legend(title="Forecast")) # SMA and SSES could not run
```

### Step 5: Forecast for 2025 with the best three models for Peru
```{r forecast 2025, warning=FALSE, message=FALSE}
# State Space with BSM Model SSES, ETS, NNETAR 

# State Space with BSM Model 
n_full = 12

# Create the time series to retain full data set
ts_Peru_fulltrain <- ts(Peru[97:276,6],
              start=c(2010, 1),
              frequency = 12)

# Fit SSES Model 
SSES_seas_totalper_fulltrain <- es(ts_Peru_fulltrain,
                         model="ZZZ", h=n_full, holdout=FALSE)

SSES_for_totalper_fulltrain <- forecast(SSES_seas_totalper_fulltrain, h=n_full)

# Plot model + observed data
autoplot(ts_Peru_fulltrain) +
  autolayer(SSES_for_totalper_fulltrain, series="SSES",PI=FALSE)+
  ylab("Forecasted Unemployment Rate (%) in Peru") 

# Fit ETS Model 
ETS_seas_totalper_fulltrain <-  stlf(ts_Peru_fulltrain,h=n_full)
ETS_for_totalper_fulltrain <- forecast(ETS_seas_totalper_fulltrain, h=n_full)

# Plot model + observed data
autoplot(ts_Peru_fulltrain) +
  autolayer(ETS_for_totalper_fulltrain, series="ETS",PI=FALSE)+
  ylab("Forecasted Unemployment Rate (%) in Peru")

# Fit SS with BSM Model 

SS_seas_totalper_fulltrain <- nnetar(ts_Peru_fulltrain,
                                     p = 3, P = 0,
                                     xreg = fourier(ts_Peru_fulltrain, K = 3))

  


SS_for_totalper_fulltrain <- forecast(SS_seas_totalper_fulltrain, 
                                      h=n_full,
                                      xreg=fourier(ts_Peru_fulltrain,
                                      K=3,h=n_full))

SS_for_totalper_fulltrain
class(SS_for_totalper_fulltrain)
autoplot(ts_Peru_fulltrain)


# Plot model + observed data
p <- autoplot(ts_Peru_fulltrain) +
  autolayer(SS_for_totalper_fulltrain, series="SS with BSM Model",PI=FALSE)+
  ylab("Forecasted Unemployment Rate (%) in Peru") 
print(p)

# Plot 3 models together 
autoplot(ts_Peru_fulltrain) +
  autolayer(SSES_for_totalper_fulltrain, series="SSES",PI=FALSE)+
  autolayer(ETS_for_totalper_fulltrain, series="ETS",PI=FALSE)+
  autolayer(SS_for_totalper_fulltrain, series="NNETAR",PI=FALSE)+
  ylab("Unemployment Rate (%)") + 
  ggtitle("Forecasted Unemployment Rate (%) in Colombia")





```

# Step 6: The average of 3 forecasts
```{r}

# --- 1. Extract predicted means ---
bsm_fc <- as.numeric(SS_for_totalper_fulltrain$mean)
sses_fc <- as.numeric(SSES_for_totalper_fulltrain$mean)
ets_fc <- as.numeric(ETS_for_totalper_fulltrain$mean)

# Compute average forecast
avg_fc <- (bsm_fc + sses_fc + ets_fc) / 3

# --- 2. Create forecast date index ---
# 마지막 월 기준 + 1개월
start_month <- as.Date("2025-01-01")  # 또는 Peru$Month의 마지막 날짜 이후
forecast_dates <- seq(from = start_month, by = "month", length.out = n_full)

# --- 3. Create forecast dataframe ---
forecast_df <- tibble(
  Month = forecast_dates,
  BSM = bsm_fc,
  SSES = sses_fc,
  ETS = ets_fc,
  Avg_Forecast = avg_fc
)

# --- 4. Export to Excel ---
write.xlsx(forecast_df, "./Forecast_Average_Peru.xlsx")

# --- 5. Extract actuals from 2020 ---
peru_actual_2020on <- Peru %>%
  filter(Month >= as.Date("2010-01-01")) %>%
  select(Month, Actual = Total.Per)

# Combine with forecast
plot_df <- bind_rows(
  tibble(Month = peru_actual_2020on$Month,
         Value = peru_actual_2020on$Actual,
         Type = "Actual"),
  tibble(Month = forecast_dates,
         Value = avg_fc,
         Type = "Avg Forecast")
)

# --- 6. Plot actuals + forecast ---
ggplot(plot_df, aes(x = Month, y = Value, color = Type, group = 1)) +
  geom_line(size = 1) +
  scale_color_manual(values = c("Actual" = "black", "Avg Forecast" = "steelblue")) +
  labs(
    title = "Colombia Unemployment Rate: Actual (2020~) + Avg Forecast (2025)",
    y = "Unemployment Rate (%)",
    x = "Month",
    color = "Legend"
  ) +
  theme_minimal()

# --- 7. Extract actuals from 2022 ---
peru_actual_2022on <- Peru %>%
  filter(Month >= as.Date("2022-01-01")) %>%
  select(Month, Actual = Total.Per)

# Combine with forecast
plot_df <- bind_rows(
  tibble(Month = peru_actual_2022on$Month,
         Value = peru_actual_2022on$Actual,
         Type = "Actual"),
  tibble(Month = forecast_dates,
         Value = avg_fc,
         Type = "Avg Forecast")
)

# --- 8. Plot actuals + forecast ---
ggplot(plot_df, aes(x = Month, y = Value, color = Type, group = 1)) +
  geom_line(size = 1) +
  scale_color_manual(values = c("Actual" = "black", "Avg Forecast" = "steelblue")) +
  labs(
    title = "Colombia Unemployment Rate: Actual (2022~) + Avg Forecast (2025)",
    y = "Unemployment Rate (%)",
    x = "Month",
    color = "Legend"
  ) +
  theme_minimal()

```


### Step 5_1: Forecast for 2025 with the best three models number
```{r forecast 2025, warning=FALSE, message=FALSE}
# State Space with BSM Model SSES, ETS, NNETAR 

# State Space with BSM Model 
n_full = 12

# Create the time series to retain full data set
ts_Peru_fulltrain <- ts(Peru_LF[97:276,"LF.Part"],
              start=c(2010, 1),
              frequency = 12)
head(ts_Peru_fulltrain)
tail(ts_Peru_fulltrain)

# Fit SSES Model 
SSES_seas_totalper_fulltrain <- es(ts_Peru_fulltrain,
                         model="ZZZ", h=n_full, holdout=FALSE)

SSES_for_totalper_fulltrain <- forecast(SSES_seas_totalper_fulltrain, h=n_full)

# Plot model + observed data
autoplot(ts_Peru_fulltrain) +
  autolayer(SSES_for_totalper_fulltrain, series="SSES",PI=FALSE)+
  ylab("Forecasted Unemployment Rate (%) in Peru") 

# Fit ETS Model 
ETS_seas_totalper_fulltrain <-  stlf(ts_Peru_fulltrain,h=n_full)
ETS_for_totalper_fulltrain <- forecast(ETS_seas_totalper_fulltrain, h=n_full)

# Plot model + observed data
autoplot(ts_Peru_fulltrain) +
  autolayer(ETS_for_totalper_fulltrain, series="ETS",PI=FALSE)+
  ylab("Forecasted Unemployment Rate (%) in Peru")

# Fit SS with BSM Model 

SS_seas_totalper_fulltrain <- nnetar(ts_Peru_fulltrain,
                                     p = 3, P = 0,
                                     xreg = fourier(ts_Peru_fulltrain, K = 3))

  


SS_for_totalper_fulltrain <- forecast(SS_seas_totalper_fulltrain, 
                                      h=n_full,
                                      xreg=fourier(ts_Peru_fulltrain,
                                      K=3,h=n_full))

SS_for_totalper_fulltrain
class(SS_for_totalper_fulltrain)
autoplot(ts_Peru_fulltrain)


# Plot model + observed data
p <- autoplot(ts_Peru_fulltrain) +
  autolayer(SS_for_totalper_fulltrain, series="SS with BSM Model",PI=FALSE)+
  ylab("Forecasted Unemployment Rate (%) in Peru") 
print(p)

# Plot 3 models together 
autoplot(ts_Peru_fulltrain) +
  autolayer(SSES_for_totalper_fulltrain, series="SSES",PI=FALSE)+
  autolayer(ETS_for_totalper_fulltrain, series="ETS",PI=FALSE)+
  autolayer(SS_for_totalper_fulltrain, series="NNETAR",PI=FALSE)+
  ylab("Unemployment Rate (%)") + 
  ggtitle("Forecasted Unemployment Rate (%) in Colombia")





```

# Step 6: The average of 3 forecasts
```{r}

# --- 1. Extract predicted means ---
bsm_fc <- as.numeric(SS_for_totalper_fulltrain$mean)
sses_fc <- as.numeric(SSES_for_totalper_fulltrain$mean)
ets_fc <- as.numeric(ETS_for_totalper_fulltrain$mean)

# Compute average forecast
avg_fc <- (bsm_fc + sses_fc + ets_fc) / 3

# --- 2. Create forecast date index ---
# 마지막 월 기준 + 1개월
start_month <- as.Date("2025-01-01")  # 또는 Peru$Month의 마지막 날짜 이후
forecast_dates <- seq(from = start_month, by = "month", length.out = n_full)

# --- 3. Create forecast dataframe ---
forecast_df <- tibble(
  Month = forecast_dates,
  BSM = bsm_fc,
  SSES = sses_fc,
  ETS = ets_fc,
  Avg_Forecast = avg_fc
)

# --- 4. Export to Excel ---
write.xlsx(forecast_df, "./Forecast_Average_Peru.xlsx")

# --- 5. Extract actuals from 2020 ---
peru_actual_2020on <- Peru_LF %>%
  filter(Month >= as.Date("2010-01-01")) %>%
  select(Month, Actual = LF.Part)

# Combine with forecast
plot_df <- bind_rows(
  tibble(Month = peru_actual_2020on$Month,
         Value = peru_actual_2020on$Actual,
         Type = "Actual"),
  tibble(Month = forecast_dates,
         Value = avg_fc,
         Type = "Avg Forecast")
)

# --- 6. Plot actuals + forecast ---
ggplot(plot_df, aes(x = Month, y = Value, color = Type, group = 1)) +
  geom_line(size = 1) +
  scale_color_manual(values = c("Actual" = "black", "Avg Forecast" = "steelblue")) +
  labs(
    title = "Colombia employment Count: Actual (2010~) + Avg Forecast (2025)",
    y = "Unemployment Count",
    x = "Month",
    color = "Legend"
  ) +
  theme_minimal()

# --- 7. Extract actuals from 2022 ---
peru_actual_2022on <- Peru_LF %>%
  filter(Month >= as.Date("2022-01-01")) %>%
  select(Month, Actual = LF.Part)

# Combine with forecast
plot_df <- bind_rows(
  tibble(Month = peru_actual_2022on$Month,
         Value = peru_actual_2022on$Actual,
         Type = "Actual"),
  tibble(Month = forecast_dates,
         Value = avg_fc,
         Type = "Avg Forecast")
)

# --- 8. Plot actuals + forecast ---
ggplot(plot_df, aes(x = Month, y = Value, color = Type, group = 1)) +
  geom_line(size = 1) +
  scale_color_manual(values = c("Actual" = "black", "Avg Forecast" = "steelblue")) +
  labs(
    title = "Colombia Unemployment Rate: Actual (2022~) + Avg Forecast (2025)",
    y = "Unemployment Rate (%)",
    x = "Month",
    color = "Legend"
  ) +
  theme_minimal()

```

Log Transformation

```{r}
# --- 9. Extract actuals from 2010 ---
peru_actual_2010on <- Peru_LF %>%
  filter(Month >= as.Date("2010-01-01")) %>%
  select(Month, Actual = LF.Part)

# Combine actual and forecast for plotting
plot_df_log <- bind_rows(
  tibble(Month = peru_actual_2010on$Month,
         Value = peru_actual_2010on$Actual,
         Type = "Actual"),
  tibble(Month = forecast_dates,
         Value = avg_fc,
         Type = "Avg Forecast")
)

# --- 10. Plot (log-transformed) ---
ggplot(plot_df_log, aes(x = Month, y = log(Value), color = Type, group = Type)) +
  geom_line(size = 1) +
  scale_color_manual(values = c("Actual" = "black", "Avg Forecast" = "steelblue")) +
  labs(
    title = "Colombia Unemployment Rate (Log Scale): Actual (2010~) + Avg Forecast (2025)",
    y = "log(Unemployment Rate)",
    x = "Month",
    color = "Legend"
  ) +
  theme_minimal()

```



## Time Series Analysis for US (Original Series)
### Step 1: Transform into time series and set training and testing windows for US (Original)
```{r time series}
# Transform into time series
ts_US <- ts(US[,2:11],
              start=c(year(US$Month[1]), month(US$Month[1])),
              frequency = 12)

# Set the period
nobsUS = nrow(US)
n_forUS = 12

# Create a subset for training purpose 
ts_US_train <- ts(US[1:(nobsUS-n_forUS),2:11],
                    start=c(year(US$Month[1]), month(US$Month[1])),
                    frequency = 12)

# Create a subset for testing purpose
start_rowUS = nobsUS - n_forUS + 1
ts_US_test <- ts(US[(nobsUS - n_forUS + 1):nobsUS,2:11],
                   start=c(year(US$Month[start_rowUS]),
                           month(US$Month[start_rowUS])), frequency = 12)

# Plots 
trainUS <- autoplot(ts_US_train[,"Total.Per"]) + ylab("Unemployment Rate (%)") +
  ggtitle("Training Window")
testUS <- autoplot(ts_US_test[,"Total.Per"]) + ylab("Unemployment Rate (%)") +
  ggtitle("Testing Window")
grid.arrange(trainUS, testUS, ncol = 2)

par(mfrow=c(1,2))
Acf(ts_US_train[,"Total.Per"], lag=40, plot = TRUE, main = "")
Pacf(ts_US_train[,"Total.Per"], lag=40, plot = TRUE, main = "")
par(mfrow=c(1,1))
```

### Step 2: Decompose the time series for US (Original)
```{r total.per decompose of US, warning=FALSE, message=FALSE}
# Decompose 
decom_totalper_trainUS <- decompose(ts_US_train[,"Total.Per"])
plot(decom_totalper_trainUS)

# Deseason 
deseas_totalper_trainUS <- seasadj(decom_totalper_trainUS)  
plot(deseas_totalper_trainUS)

# Run the tests on deseasoned series
print(adf.test(deseas_totalper_trainUS, alternative = "stationary")) # It is stationary. 
summary(MannKendall(deseas_totalper_trainUS)) # It has a decreasing trend.

# Run the tests on original series 
print(adf.test(ts_US_train[,"Total.Per"], alternative = "stationary")) # It is stationary. 
summary(SeasonalMannKendall(ts_US_train[,"Total.Per"])) 
summary(smk.test(ts_US_train[,"Total.Per"])) # It has seasonality. 

# Check for any differencing needed 
print(ndiffs(ts_US_train[,"Total.Per"]))
print(ndiffs(deseas_totalper_trainUS))
```

### Step 3: Test Time Series Models for US (Original)
```{r time series models, warning=FALSE, message=FALSE}
# Seasonal Naive Model 
SNAIVE_deseas_totalperUS <- snaive(ts_US_train[,"Total.Per"], h=n_forUS)
autoplot(SNAIVE_deseas_totalperUS)
checkresiduals(SNAIVE_deseas_totalperUS) # Residuals are not iid. 

# Simple Moving Average Model
SMA_deseas_totalperUS <- smooth::sma(y = deseas_totalper_trainUS, h=n_forUS, 
                                     holdout = FALSE, silent = FALSE) 
summary(SMA_deseas_totalperUS)
checkresiduals(SMA_deseas_totalperUS) # Residuals are iid. 

# Simple Exponential Smoothing Model
SES_deseas_totalperUS = ses( y = deseas_totalper_trainUS, h=n_forUS, 
                             holdout = FALSE, silent = FALSE)  
summary(SES_deseas_totalperUS)
autoplot(SES_deseas_totalperUS)
checkresiduals(SES_deseas_totalperUS) # Residuals are iid. 

# SARIMA Model
SARIMA_totalperUS <- auto.arima(ts_US_train[,"Total.Per"])
print(SARIMA_totalperUS)

SARIMA_forecast_totalperUS <- forecast(object = SARIMA_totalperUS, h=n_forUS)
autoplot(SARIMA_forecast_totalperUS)
checkresiduals(SARIMA_forecast_totalperUS) # Residuals are iid.

# Deaseasoned ARIMA Model
ARIMA_totalperUS <- auto.arima(deseas_totalper_trainUS, max.D = 0, 
                               max.P = 0, max.Q = 0)
print(ARIMA_totalperUS)

ARIMA_forecast_totalperUS <- forecast(object = ARIMA_totalperUS, h=n_forUS)
autoplot(ARIMA_forecast_totalperUS)
checkresiduals(ARIMA_forecast_totalperUS) # Residuals are iid.
 
# STL + ETS Model
ETS_totalperUS <-  stlf(ts_US_train[,"Total.Per"],h=n_forUS)
autoplot(ETS_totalperUS) 
checkresiduals(ETS_totalperUS) # Residuals are iid. 

# ARIMA + FOURIER Model
ARIMA_Four_fit_totalperUS <- auto.arima(ts_US_train[,"Total.Per"], 
                             seasonal=FALSE, lambda=0,
                             xreg=fourier(ts_US_train[,"Total.Per"], 
                                          K=3))

ARIMA_Four_for_totalperUS <- forecast(ARIMA_Four_fit_totalperUS,
                           xreg=fourier(ts_US_train[,"Total.Per"],
                                        K=3, h=n_forUS),
                           h=n_forUS) 

autoplot(ARIMA_Four_for_totalperUS)
checkresiduals(ARIMA_Four_for_totalperUS) # Residuals are iid. 

# TBATS Model 
TBATS_fit_totalperUS <- tbats(ts_US_train[,"Total.Per"])
TBATS_for_totalperUS <- forecast(TBATS_fit_totalperUS, h = n_forUS)
autoplot(TBATS_for_totalperUS) 
checkresiduals(TBATS_fit_totalperUS) # Residuals are iid. 

# Neural Network Model 
NN_fit_totalperUS <- nnetar(ts_US_train[,"Total.Per"],
                 p=3, P=0,
                 xreg=fourier(ts_US_train[,"Total.Per"], K=3))

NN_for_totalperUS <- forecast(NN_fit_totalperUS, 
                   h=n_forUS,
                   xreg=fourier(ts_US_train[,"Total.Per"], 
                                          K=3,h=n_forUS))

autoplot(NN_for_totalperUS)
checkresiduals(NN_fit_totalperUS) # Residuals are iid. 

## State Space Exponential Smoothing Model
SSES_seas_totalperUS <- es(ts_US_train[,"Total.Per"],
                         model="ZZZ", h=n_forUS, holdout=FALSE)
checkresiduals(SSES_seas_totalperUS) # Residuals are iid.

## State Space with BSM Model
SS_seas_totalperUS <- StructTS(ts_US_train[,"Total.Per"],
                    type="BSM",fixed=c(0.01,0.001,0.1,NA)) 

SS_for_totalperUS <- forecast(SS_seas_totalperUS,h=n_forUS)

plot(SS_for_totalperUS)
checkresiduals(SS_seas_totalperUS) # Residuals are not iid. 
```

### Step 4: Performance check for US (Original)
```{r accuracy US, warning=FALSE, message=FALSE}
# Check accuracy of the models
SANIVE_tpscoresUS <- accuracy(SNAIVE_deseas_totalperUS$mean,ts_US_test[,"Total.Per"])  
SMA_tpscoresUS <- accuracy(SMA_deseas_totalperUS$forecast,ts_US_test[,"Total.Per"])  
SES_tpscoresUS <- accuracy(SES_deseas_totalperUS$mean,ts_US_test[,"Total.Per"])
SARIMA_tpscoresUS <- accuracy(SARIMA_forecast_totalperUS$mean,ts_US_test[,"Total.Per"])
ARIMA_tpscoresUS <- accuracy(ARIMA_forecast_totalperUS$mean,ts_US_test[,"Total.Per"])
ETS_tpscoresUS <- accuracy(ETS_totalperUS$mean,ts_US_test[,"Total.Per"])
ARIMA_Four_tpscoresUS <- accuracy(ARIMA_Four_for_totalperUS$mean,ts_US_test[,"Total.Per"])
TBATS_tpscoresUS <- accuracy(TBATS_for_totalperUS$mean,ts_US_test[,"Total.Per"])
NN_tpscoresUS <- accuracy(NN_for_totalperUS$mean,ts_US_test[,"Total.Per"])
SSES_tpscoresUS <- accuracy(SSES_seas_totalperUS$forecast,ts_US_test[,"Total.Per"])
SS_tpscoresUS <- accuracy(SS_for_totalperUS$mean,ts_US_test[,"Total.Per"])

# Compare the matrix 
tpscoresUS <- as.data.frame(rbind(SANIVE_tpscoresUS, SMA_tpscoresUS, 
                                SES_tpscoresUS, SARIMA_tpscoresUS, ARIMA_tpscoresUS, 
                                ETS_tpscoresUS, ARIMA_Four_tpscoresUS, TBATS_tpscoresUS, 
                                NN_tpscoresUS, SSES_tpscoresUS, SS_tpscoresUS)) %>%
  mutate(Average = rowMeans(., na.rm = TRUE))

row.names(tpscoresUS) <- c("SNAIVE", "SMA", "SES", "SARIMA", "ARIMA",
                       "ETS", "ARIMA_FOURIER", "TBATS", "NNETAR",
                       "SSES", "BSM")

# Choose model with lowest error
best_model_index_tpUS <- which.min(tpscoresUS[,"Average"])
cat("The best model by Average is:", row.names(tpscoresUS[best_model_index_tpUS,]))  

# Create Tables 
kbl(tpscoresUS, 
      caption = "Forecast Accuracy for Unemployment Rate (%) Data",
      digits = array(5,ncol(tpscoresUS))) %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  #highlight model with lowest RMSE
  kable_styling(latex_options="striped", stripe_index = which.min(seas_scores[,"Average"]))

# Plot everything together
autoplot(ts_US_test[,"Total.Per"]) +
  autolayer(SNAIVE_deseas_totalperUS, PI=FALSE, series="SNAIVE") + 
  autolayer(SES_deseas_totalperUS, PI=FALSE, series="SES") +
  autolayer(SARIMA_forecast_totalperUS, PI=FALSE, series="SARIMA") +
  autolayer(ARIMA_forecast_totalperUS, PI=FALSE, series="ARIMA") +
  autolayer(ETS_totalperUS, PI=FALSE, series="ETS") +
  autolayer(ARIMA_Four_for_totalperUS, PI=FALSE, series="ARIMA_FOURIER") +
  autolayer(TBATS_for_totalperUS, PI=FALSE, series="TBATS") +
  autolayer(NN_for_totalperUS, PI=FALSE, size=0.7, series="NNETAR") +
  autolayer(SS_for_totalperUS, PI=FALSE, series="BSM") +
  guides(colour=guide_legend(title="Forecast")) # SMA and SSES could not run
```

### Step 5: Forecast for 2025 with the best three models for US (Original)
# Jisup: I think that SARIMA model cannot explain COVID. That's why the model is Forecast method: ARIMA(0,1,0). I tried several times but SARIMA could not make any better.
```{r forecast 2025 US original, warning=FALSE, message=FALSE}
# Set the forecasting period
n_fullUS = 12

# Create the time series to retain full data set
ts_US_fulltrain <- ts(US[,6],
              start=c(year(US$Month[1]), month(US$Month[1])),
              frequency = 12)

# Fit SS with BSM Model 
SS_seas_totalper_fulltrainUS <- StructTS(ts_US_fulltrain,
                    type="BSM",fixed=c(0.01,0.001,0.1,NA)) 

SS_for_totalper_fulltrainUS <- forecast(SS_seas_totalper_fulltrainUS,h=n_fullUS)

# Plot model + observed data
autoplot(ts_US_fulltrain) +
  autolayer(SS_for_totalper_fulltrainUS, series="SS with BSM Model",PI=FALSE)+
  ylab("Forecasted Unemployment Rate (%) in US") 

# Fit STL + ETS Model
ETS_totalper_fulltrainUS <-  stlf(ts_US_fulltrain,h=n_fullUS)

# Plot model + observed data
autoplot(ts_US_fulltrain) +
  autolayer(ETS_totalper_fulltrainUS, series="ETS",PI=FALSE)+
  ylab("Forecasted Unemployment Rate (%) in US")

# Simple Exponential Smoothing Model
decom_totalper_fulltrainUS <- decompose(ts_US_fulltrain)
deseas_totalper_fulltrainUS <- seasadj(decom_totalper_fulltrainUS)
SES_deseas_totalper_fulltrainUS = ses( y = deseas_totalper_fulltrainUS,
                                       h=n_fullUS,    holdout = FALSE,
                                       silent = FALSE)  

# Plot model + observed data
autoplot(ts_US_fulltrain) +
  autolayer(SES_deseas_totalper_fulltrainUS, series="SES Model",PI=FALSE)+
  ylab("Forecasted Unemployment Rate (%) in US") 

# SARIMA Model
autoplot(ts_US_fulltrain)
SARIMA_totalper_fulltrainUS <- auto.arima(ts_US_fulltrain)
summary(SARIMA_totalper_fulltrainUS)
SARIMA_forecast_totalper_fulltrainUS <- forecast(object = SARIMA_totalper_fulltrainUS, h=n_fullUS)
summary(SARIMA_forecast_totalper_fulltrainUS)
# Plot model + observed data
autoplot(ts_US_fulltrain) +
  autolayer(SARIMA_forecast_totalper_fulltrainUS, series="SARIMA Model",PI=FALSE)+
  ylab("Forecasted Unemployment Rate (%) in US") 

# Plot 4 models together 
autoplot(ts_US_fulltrain) +
  autolayer(SS_for_totalper_fulltrainUS, series="SS with BSM Model",PI=FALSE)+
  autolayer(ETS_totalper_fulltrainUS, series="ETS",PI=FALSE)+
  autolayer(SES_deseas_totalper_fulltrainUS, series="SES Model",PI=FALSE)+
  autolayer(SARIMA_forecast_totalper_fulltrainUS, series="SARIMA Model",PI=FALSE)+
  ylab("Unemployment Rate (%)") + 
  ggtitle("Forecasted Unemployment Rate (%) in US")
```

## Time Series Analysis for US (Outliers-removed Series)
### Step 1: Transform into time series and set training and testing windows for US (Outliers)
```{r time series US}
# Remove outliers 
ts_USout <- tsclean(ts_US[,"Total.Per"]) 

autoplot(ts_USout, series="Outliers-removed Series") +
  autolayer(ts_US[,"Total.Per"], series="Original Series") +
  ylab("Unemployment Rate (%)") 

# Create a subset for training purpose 
ts_US_trainout <- ts(ts_USout[1:(nobsUS-n_forUS)],
                    start=c(year(US$Month[1]), month(US$Month[1])),
                    frequency = 12)

# Create a subset for testing purpose
ts_US_testout <- ts(ts_USout[(nobsUS - n_forUS + 1):nobsUS],
                   start=c(year(US$Month[start_rowUS]),
                           month(US$Month[start_rowUS])), frequency = 12)

# Plots 
trainUSout <- autoplot(ts_US_trainout) + ylab("Unemployment Rate (%)") +
  ggtitle("Training Window")
testUSout <- autoplot(ts_US_testout) + ylab("Unemployment Rate (%)") +
  ggtitle("Testing Window")
grid.arrange(trainUSout, testUSout, ncol = 2)

par(mfrow=c(1,2))
Acf(ts_US_trainout, lag=40, plot = TRUE, main = "")
Pacf(ts_US_trainout, lag=40, plot = TRUE, main = "")
par(mfrow=c(1,1))
```

### Step 2: Decompose the time series for US (Outliers)
```{r total.per decompose, warning=FALSE, message=FALSE}
# Decompose 
decom_totalper_trainUSout <- decompose(ts_US_trainout)
plot(decom_totalper_trainUSout)

# Deseason 
deseas_totalper_trainUSout <- seasadj(decom_totalper_trainUSout)  
plot(deseas_totalper_trainUSout)

# Run the tests on deseasoned series
print(adf.test(deseas_totalper_trainUSout, alternative = "stationary")) # It is unit root. 
summary(MannKendall(deseas_totalper_trainUSout)) # It has a decreasing trend.

# Run the tests on original series 
print(adf.test(ts_US_trainout, alternative = "stationary")) # It is unit out. 
summary(SeasonalMannKendall(ts_US_trainout)) 
summary(smk.test(ts_US_trainout)) # It has seasonality. 

# Check for any differencing needed 
print(ndiffs(ts_US_trainout))
print(ndiffs(deseas_totalper_trainUSout))
```

### Step 3: Test Time Series Models for US (Outliers)
```{r time series models US, warning=FALSE, message=FALSE}
# Seasonal Naive Model 
SNAIVE_deseas_totalperUSout <- snaive(ts_US_trainout, h=n_forUS)
autoplot(SNAIVE_deseas_totalperUSout)
checkresiduals(SNAIVE_deseas_totalperUSout)

# Simple Moving Average Model
SMA_deseas_totalperUSout <- smooth::sma(y = deseas_totalper_trainUSout, h=n_forUS, 
                                     holdout = FALSE, silent = FALSE) 
summary(SMA_deseas_totalperUSout)
checkresiduals(SMA_deseas_totalperUSout)

# Simple Exponential Smoothing Model
SES_deseas_totalperUSout = ses( y = deseas_totalper_trainUSout, h=n_forUS, 
                             holdout = FALSE, silent = FALSE)  
summary(SES_deseas_totalperUSout)
autoplot(SES_deseas_totalperUSout)
checkresiduals(SES_deseas_totalperUSout)

# SARIMA Model
SARIMA_totalperUSout <- auto.arima(ts_US_trainout)
print(SARIMA_totalperUSout)

SARIMA_forecast_totalperUSout <- forecast(object = SARIMA_totalperUSout, h=n_forUS)
autoplot(SARIMA_forecast_totalperUSout)
checkresiduals(SARIMA_forecast_totalperUSout) # Residuals are not iid.

# Deaseasoned ARIMA Model
ARIMA_totalperUSout <- auto.arima(deseas_totalper_trainUSout, max.D = 0, 
                               max.P = 0, max.Q = 0)
print(ARIMA_totalperUSout)

ARIMA_forecast_totalperUSout <- forecast(object = ARIMA_totalperUSout, h=n_forUS)
autoplot(ARIMA_forecast_totalperUSout)
checkresiduals(ARIMA_forecast_totalperUSout) # Residuals are iid.
 
# STL + ETS Model
ETS_totalperUSout <-  stlf(ts_US_trainout,h=n_forUS)
autoplot(ETS_totalperUSout) 
checkresiduals(ETS_totalperUSout) # Residuals are not iid. 

# ARIMA + FOURIER Model
ARIMA_Four_fit_totalperUSout <- auto.arima(ts_US_trainout, 
                             seasonal=FALSE, lambda=0,
                             xreg=fourier(ts_US_trainout, 
                                          K=3))

ARIMA_Four_for_totalperUSout <- forecast(ARIMA_Four_fit_totalperUSout,
                           xreg=fourier(ts_US_trainout,
                                        K=3, h=n_forUS),
                           h=n_forUS) 

autoplot(ARIMA_Four_for_totalperUSout)
checkresiduals(ARIMA_Four_for_totalperUSout) # Residuals are not iid. 

# TBATS Model 
TBATS_fit_totalperUSout <- tbats(ts_US_trainout)
TBATS_for_totalperUSout <- forecast(TBATS_fit_totalperUSout, h = n_forUS)
autoplot(TBATS_for_totalperUSout) 
checkresiduals(TBATS_fit_totalperUSout) # Residuals are not iid. 

# Neural Network Model 
NN_fit_totalperUSout <- nnetar(ts_US_trainout,
                 p=3, P=0,
                 xreg=fourier(ts_US_trainout, K=3))

NN_for_totalperUSout <- forecast(NN_fit_totalperUSout, 
                   h=n_forUS,
                   xreg=fourier(ts_US_trainout, 
                                          K=3,h=n_forUS))

autoplot(NN_for_totalperUSout)
checkresiduals(NN_fit_totalperUSout) # Residuals are not iid. 

## State Space Exponential Smoothing Model
SSES_seas_totalperUSout <- es(ts_US_trainout,
                         model="ZZZ", h=n_forUS, holdout=FALSE)
checkresiduals(SSES_seas_totalperUSout) # Residuals are not iid.

## State Space with BSM Model
SS_seas_totalperUSout <- StructTS(ts_US_trainout,
                    type="BSM",fixed=c(0.01,0.001,0.1,NA)) 

SS_for_totalperUSout <- forecast(SS_seas_totalperUSout,h=n_forUS)

plot(SS_for_totalperUSout)
checkresiduals(SS_seas_totalperUSout) # Residuals are not iid. 
```

### Step 4: Performance check for US (Outliers)
```{r accuracy, warning=FALSE, message=FALSE}
# Check accuracy of the models
SANIVE_tpscoresUSout <- accuracy(SNAIVE_deseas_totalperUSout$mean,ts_US_testout)  
SMA_tpscoresUSout <- accuracy(SMA_deseas_totalperUSout$forecast,ts_US_testout)  
SES_tpscoresUSout <- accuracy(SES_deseas_totalperUSout$mean,ts_US_testout)
SARIMA_tpscoresUSout <- accuracy(SARIMA_forecast_totalperUSout$mean,ts_US_testout)
ARIMA_tpscoresUSout <- accuracy(ARIMA_forecast_totalperUSout$mean,ts_US_testout)
ETS_tpscoresUSout <- accuracy(ETS_totalperUSout$mean,ts_US_testout)
ARIMA_Four_tpscoresUSout <- accuracy(ARIMA_Four_for_totalperUSout$mean,ts_US_testout)
TBATS_tpscoresUSout <- accuracy(TBATS_for_totalperUSout$mean,ts_US_testout)
NN_tpscoresUSout <- accuracy(NN_for_totalperUSout$mean,ts_US_testout)
SSES_tpscoresUSout <- accuracy(SSES_seas_totalperUSout$forecast,ts_US_testout)
SS_tpscoresUSout <- accuracy(SS_for_totalperUSout$mean,ts_US_testout)

# Compare the matrix 
tpscoresUSout <- as.data.frame(rbind(SANIVE_tpscoresUSout, SMA_tpscoresUSout, 
                                SES_tpscoresUSout, SARIMA_tpscoresUSout, ARIMA_tpscoresUSout, 
                                ETS_tpscoresUSout, ARIMA_Four_tpscoresUSout, TBATS_tpscoresUSout, 
                                NN_tpscoresUSout, SSES_tpscoresUSout, SS_tpscoresUSout)) %>%
  mutate(Average = rowMeans(., na.rm = TRUE))

row.names(tpscoresUSout) <- c("SNAIVE", "SMA", "SES", "SARIMA", "ARIMA",
                       "ETS", "ARIMA_FOURIER", "TBATS", "NNETAR",
                       "SSES", "BSM")

# Choose model with lowest error
best_model_index_tpUSout <- which.min(tpscoresUSout[,"Average"])
cat("The best model by Average is:", row.names(tpscoresUSout[best_model_index_tpUSout,]))  

# Create Tables 
kbl(tpscoresUSout, 
      caption = "Forecast Accuracy for Unemployment Rate (%) Data",
      digits = array(5,ncol(tpscoresUSout))) %>%
  kable_styling(full_width = FALSE, position = "center") %>%
  #highlight model with lowest RMSE
  kable_styling(latex_options="striped", stripe_index = which.min(seas_scores[,"Average"]))

# Plot everything together
autoplot(ts_US_testout) +
  autolayer(SNAIVE_deseas_totalperUSout, PI=FALSE, series="SNAIVE") + 
  autolayer(SES_deseas_totalperUSout, PI=FALSE, series="SES") +
  autolayer(SARIMA_forecast_totalperUSout, PI=FALSE, series="SARIMA") +
  autolayer(ARIMA_forecast_totalperUSout, PI=FALSE, series="ARIMA") +
  autolayer(ETS_totalperUSout, PI=FALSE, series="ETS") +
  autolayer(ARIMA_Four_for_totalperUSout, PI=FALSE, series="ARIMA_FOURIER") +
  autolayer(TBATS_for_totalperUSout, PI=FALSE, series="TBATS") +
  autolayer(NN_for_totalperUSout, PI=FALSE, series="NNETAR") +
  autolayer(SS_for_totalperUSout, PI=FALSE, series="BSM") +
  guides(colour=guide_legend(title="Forecast")) # SMA and SSES could not run
```

### Step 5: Forecast for 2025 with the best three models for US (Outliers)
```{r forecast 2025 US, warning=FALSE, message=FALSE}
# Set the forecasting period
n_fullUS = 12

# Create the time series to retain full data set
ts_US_fulltrainout <- ts(ts_USout,
              start=c(year(US$Month[1]), month(US$Month[1])),
              frequency = 12)

# Fit SS with BSM Model 
SS_seas_totalper_fulltrainUSout <- StructTS(ts_US_fulltrainout,
                    type="BSM",fixed=c(0.01,0.001,0.1,NA)) 

SS_for_totalper_fulltrainUSout <- forecast(SS_seas_totalper_fulltrainUSout,h=n_fullUS)

# Plot model + observed data
autoplot(ts_US_fulltrainout) +
  autolayer(SS_for_totalper_fulltrainUSout, series="SS with BSM Model",PI=FALSE)+
  ylab("Forecasted Unemployment Rate (%) in US") 

# Fit Neural Network Model 
NN_fit_totalper_fulltrainUSout <- nnetar(ts_US_fulltrainout,
                 p=3, P=0,
                 xreg=fourier(ts_US_fulltrainout, K=3))

NN_for_totalper_fulltrainUSout <- forecast(NN_fit_totalper_fulltrainUSout, 
                   h=n_fullUS,
                   xreg=fourier(ts_US_fulltrainout, 
                                          K=3,h=n_fullUS))

# Plot model + observed data
autoplot(ts_US_fulltrainout) +
  autolayer(NN_for_totalper_fulltrainUSout, series="NNETAR",PI=FALSE)+
  ylab("Forecasted Unemployment Rate (%) in US")

# Fit STL + ETS Model
ETS_totalper_fulltrainUSout <-  stlf(ts_US_fulltrainout,h=n_fullUS)

# Plot model + observed data
autoplot(ts_US_fulltrainout) +
  autolayer(ETS_totalper_fulltrainUSout, series="ETS",PI=FALSE)+
  ylab("Forecasted Unemployment Rate (%) in US")

# Plot 4 models together 
autoplot(ts_US_fulltrain) +
  autolayer(SS_for_totalper_fulltrainUSout, series="SS with BSM Model",PI=FALSE)+
  autolayer(NN_for_totalper_fulltrainUSout, series="NNETAR",PI=FALSE)+
  autolayer(ETS_totalper_fulltrainUSout, series="ETS",PI=FALSE)+
  ylab("Unemployment Rate (%)") + 
  ggtitle("Forecasted Unemployment Rate (%) in US (Outliers Removed)")
```

# Jisup: I added the average of 3 models above. I could not decide which is the best. :)

```{r}

# --- 1. Calculate the average forecast of the three models ---
# Extract predicted means
bsm_fc <- as.numeric(SS_for_totalper_fulltrainUSout$mean)
nnar_fc <- as.numeric(NN_for_totalper_fulltrainUSout$mean)
ets_fc <- as.numeric(ETS_totalper_fulltrainUSout$mean)

# Compute average forecast
avg_fc <- (bsm_fc + nnar_fc + ets_fc) / 3


# Create date index for forecast
start_date <- as.Date(paste0(end(US$Month)[1] + 1, "-", end(US$Month)[2], "-01"))  # 1 month after last
forecast_dates <- seq(from = as.Date("2025-01-01"), by = "month", length.out = n_fullUS)

# Create forecast dataframe
forecast_df <- tibble(
  Month = forecast_dates,
  BSM = bsm_fc,
  NNAR = nnar_fc,
  ETS = ets_fc,
  Avg_Forecast = avg_fc
)

# --- 2. Export forecast to Excel ---
write.xlsx(forecast_df, "./Forecast_Average_US.xlsx")

# --- 3. Plot actuals (from 2020) and forecast average ---
# Extract actual values after 2020
us_actual_2020on <- US %>%
  filter(Month >= as.Date("2020-01-01")) %>%
  select(Month, Actual = Total.Per)


# Combine with forecast
plot_df <- bind_rows(
  tibble(Month = us_actual_2020on$Month,
         Value = us_actual_2020on$Actual,
         Type = "Actual"),
  tibble(Month = forecast_dates,
         Value = avg_fc,
         Type = "Avg Forecast")
)

# --- 4. Plot actuals (from 2022) and forecast average ---
# Extract actual values after 2022
us_actual_2022on <- US %>%
  filter(Month >= as.Date("2022-01-01")) %>%
  select(Month, Actual = Total.Per)


# Combine with forecast
plot_df <- bind_rows(
  tibble(Month = us_actual_2022on$Month,
         Value = us_actual_2022on$Actual,
         Type = "Actual"),
  tibble(Month = forecast_dates,
         Value = avg_fc,
         Type = "Avg Forecast")
)


# Plot
ggplot(plot_df, aes(x = Month, y = Value, color = Type, group = 1)) +
  geom_line(size = 1) +
  scale_color_manual(values = c("Actual" = "black", "Avg Forecast" = "steelblue")) +
  labs(
    title = "US Unemployment Rate: Actual (2022~) + Avg Forecast (2025)",
    y = "Unemployment Rate (%)",
    x = "Month",
    color = "Legend"
  ) +
  theme_minimal()


```

